# 方案对比与选型建议

> 快速对比V1和V2方案，帮助你做出最佳选择

---

## 📊 核心对比表

| 维度 | V1方案（轻量） | V2方案（专业） |
|------|--------------|--------------|
| **复杂度** | ⭐⭐ 简单 | ⭐⭐⭐⭐ 复杂 |
| **Bundle大小** | ~500KB | ~2MB (gzipped) |
| **多文件定位速度** | 遍历所有文件 (~1-2秒) | SQL索引查询 (~50-100ms) |
| **代码定位精度** | 语义标记 (80%) | AST查询 (95%+) |
| **批量修改能力** | 不支持 | ✅ 支持事务式批量修改 |
| **适合项目规模** | <10个HTML页面 | 任意规模 |
| **学习曲线** | 低 | 中等 |
| **维护成本** | 低 | 中等 |

---

## 🎯 你应该选择哪个方案？

### 选择 V1 方案，如果你：

✅ 生成的网站页面数 **< 10个**
✅ 修改操作主要是**单文件单位置**
✅ 希望**快速上线**（2-3周）
✅ 希望保持项目**轻量级**
✅ 团队对数据库、AST不熟悉

**典型场景：**
- 个人博客生成器
- 小型企业官网生成器
- MVP快速验证

---

### 选择 V2 方案，如果你：

✅ 生成的网站页面数 **> 10个**
✅ 需要频繁进行**多文件批量修改**
✅ 需要**精确的代码定位**（如"所有包含X类的按钮"）
✅ 可以接受更长的开发周期（6-8周）
✅ 团队有数据库/AST相关经验

**典型场景：**
- 专业网站生成器
- 企业级代码管理工具
- 需要复杂代码搜索的场景

---

## 🔍 具体场景对比

### 场景1：修改单个页面的某个按钮

| 方案 | 实现方式 | 性能 |
|------|---------|------|
| **V1** | 语义标记直接定位 | ⚡ 极快 (<100ms) |
| **V2** | SQL查询索引 | ⚡ 极快 (<100ms) |

**结论：两者相当**

---

### 场景2：修改所有页面的导航栏样式

| 方案 | 实现方式 | 性能 | 准确度 |
|------|---------|------|--------|
| **V1** | 遍历所有文件，DOMParser解析，语义标记匹配 | 🐌 较慢 (~2秒) | 80% |
| **V2** | SQL查询AST索引，一次返回所有匹配 | ⚡ 极快 (~100ms) | 95%+ |

**结论：V2明显更优**

---

### 场景3：重命名一个CSS类（跨HTML/CSS/JS）

| 方案 | 实现方式 | 支持程度 |
|------|---------|---------|
| **V1** | 字符串搜索替换 | ⚠️ 可能误匹配（如注释中的同名类） |
| **V2** | Tree-sitter AST查询 | ✅ 精确匹配（只修改实际使用的地方） |

**结论：V2明显更优**

---

### 场景4：删除页面后清理所有引用

| 方案 | 实现方式 | 可靠性 |
|------|---------|--------|
| **V1** | 依赖图分析 + 字符串搜索 | ⚠️ 可能遗漏或误删 |
| **V2** | SQL关系查询 + AST验证 | ✅ 精确且可靠 |

**结论：V2明显更优**

---

## 💰 成本对比

### 开发成本

| 阶段 | V1 | V2 |
|------|----|----|
| 基础架构 | 1周 | 2-3周 |
| 核心功能 | 2周 | 4周 |
| UI与交互 | 1周 | 2周 |
| 优化测试 | 1周 | 2周 |
| **总计** | **5-6周** | **10-11周** |

### 运行成本

| 项目 | V1 | V2 |
|------|----|----|
| Bundle大小 | ~500KB | ~2MB |
| 首次加载时间 | 快 | 中等 |
| 内存占用 | 低 (~50MB) | 中等 (~150MB) |
| 数据库初始化 | 无 | ~500ms |

---

## 🚀 混合方案（推荐）

你也可以采用**渐进式升级**策略：

### 阶段1：先实施V1（快速验证）
- 2-3周完成MVP
- 验证核心功能和用户需求
- 积累真实使用数据

### 阶段2：评估是否需要升级
如果出现以下情况，考虑升级到V2：
- ✓ 用户生成的网站页面数 > 10
- ✓ 多文件修改操作频繁
- ✓ 用户抱怨定位不准确
- ✓ 用户需要复杂的代码搜索

### 阶段3：平滑升级到V2
V1和V2的核心架构兼容，可以平滑升级：

```javascript
// V1代码
const locations = await locator.locateBySemanticMarker(description);

// 升级到V2，只需添加PGlite层
const indexing = await loadCodeIndexing(); // 懒加载
const locations = await locator.locateBySQL(description, versionId);
// 如果SQL不够精确，fallback到V1
if (locations.length === 0) {
  locations = await locator.locateBySemanticMarker(description);
}
```

---

## 📋 技术栈对比

### V1技术栈（轻量）
```
- DOMParser (浏览器原生)
- localStorage
- IndexedDB
- marked.js (Markdown渲染)
- highlight.js (代码高亮)

总大小: ~500KB
```

### V2技术栈（专业）
```
- DOMParser (浏览器原生)
- PGlite (3MB) - PostgreSQL WASM数据库
- web-tree-sitter (~100KB) - AST解析
- tree-sitter-html.wasm (~200KB)
- tree-sitter-css.wasm (~200KB)
- tree-sitter-javascript.wasm (~200KB)
- LZ-String (5KB) - 压缩
- localStorage
- IndexedDB

总大小: ~3.9MB (gzipped后~2MB)
```

---

## 🎓 学习曲线对比

### V1方案需要理解的概念
1. DOM操作
2. 语义标记系统
3. 基础的依赖分析
4. localStorage/IndexedDB基础

**学习时间：** ~1-2天

---

### V2方案需要理解的概念
1. V1的所有概念
2. SQL查询和索引
3. AST（抽象语法树）
4. Tree-sitter Query Language
5. 数据库Schema设计
6. 事务处理

**学习时间：** ~1周

---

## ⚖️ 我的推荐

### 推荐方案：**V1先行，按需升级**

**理由：**

1. **快速验证** - V1可以在2-3周内上线，快速验证产品想法
2. **成本可控** - 避免过度设计，先做最小可行产品
3. **平滑升级** - V1可以无缝升级到V2，投入不浪费
4. **风险降低** - 先用简单方案验证需求，确认有价值后再投入更多资源

**具体建议：**

```
Phase 1 (2-3周): 实施V1方案
  ├─ 基础页面生成
  ├─ 简单编辑（单文件单位置）
  ├─ 版本管理
  └─ 基础依赖分析

Phase 2 (1周): 收集反馈
  ├─ 真实用户测试
  ├─ 性能数据收集
  └─ 需求优先级排序

Phase 3 (决策点): 评估是否需要V2
  如果需要 → 开始6-8周的V2升级
  如果不需要 → 继续优化V1

Phase 4 (可选): 升级到V2
  ├─ 集成PGlite
  ├─ 集成web-tree-sitter
  ├─ 实现多文件定位
  └─ 实现批量修改
```

---

## 🤔 常见问题

### Q1: V1方案能处理多文件编辑吗？

**A:** 可以，但性能和精度不如V2。

- V1需要遍历所有文件（对于10个文件，大约1-2秒）
- V2使用SQL索引查询（对于100个文件，也只需100ms）

### Q2: V2方案会让首次加载变慢吗？

**A:** 可以通过懒加载避免。

```javascript
// 只在需要多文件操作时才加载PGlite和tree-sitter
const loadAdvancedFeatures = async () => {
  if (!window.advancedFeaturesLoaded) {
    await Promise.all([
      loadPGlite(),
      loadTreeSitter()
    ]);
    window.advancedFeaturesLoaded = true;
  }
};
```

### Q3: 可以只用tree-sitter，不用PGlite吗？

**A:** 可以，但会损失很多优势。

- 没有PGlite，就没有SQL查询能力
- 每次搜索都需要解析所有文件（慢）
- 无法做高效的全文搜索
- 依赖关系需要手动维护

### Q4: PGlite数据是否持久化？

**A:** 是的，PGlite支持多种持久化方式：

```javascript
// 方式1: 使用OPFS (Origin Private File System)
const db = new PGlite('idb://my-database');

// 方式2: 使用IndexedDB
const db = new PGlite({
  dataDir: 'indexeddb://my-db'
});

// 刷新页面后数据仍然存在
```

---

## 📊 最终建议矩阵

|  | 页面数<5 | 页面数5-15 | 页面数>15 |
|--|---------|-----------|----------|
| **简单修改为主** | V1 ✅ | V1 ✅ | V1 或 V2 |
| **多文件批量修改** | V1 | V2 ✅ | V2 ✅ |
| **复杂代码搜索** | V1 | V2 ✅ | V2 ✅ |

---

## 🎯 总结

- **快速MVP** → 选 V1
- **长期产品** → 选 V2 或 V1→V2 渐进升级
- **不确定** → 选 V1 先行，保留升级空间

两个方案都是可行的，关键是根据你的**实际需求**和**资源情况**做选择。

如果还有疑问，可以继续问我！🚀
